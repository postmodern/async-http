<!DOCTYPE html>
<html>
	<head>
		
			<title>Async::HTTP::Protocol::HTTP2::Stream</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		<script src="../../../../../../_components/mermaid/mermaid.min.js"></script>
		
		<script src="../../../../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
			
			let isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
			let config = {theme: 'light'};
			if (isDarkMode) config.theme = 'dark';
			else config.theme = 'forest';
			mermaid.initialize(config);
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../../../../index.html">Project</a> › <a class="link" href="../../../../../index.html">Source</a></header>
		
		<main>
			
	<h1>Async::HTTP::Protocol::HTTP2::Stream</h1>
	
	<p>
		<code class="language-ruby">class Async::HTTP::Protocol::HTTP2::Stream &lt; ::Protocol::HTTP2::Stream</code>
	</p>
	
		
	
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="Async::HTTP::Protocol::HTTP2::Stream#prepare_input"><h3><code class="language-ruby">def prepare_input(length)</code></h3><p>Prepare the input stream which will be used for incoming data frames.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def prepare_input(length)
	if @input.nil?
		@input = Input.new(self, length)
	else
		raise ArgumentError, &quot;Input body already prepared!&quot;
	end
end</code></pre>
					</details></section><section id="Async::HTTP::Protocol::HTTP2::Stream#send_body"><h3><code class="language-ruby">def send_body(body, trailer = nil)</code></h3><p>Set the body and begin sending it.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def send_body(body, trailer = nil)
	@output = Output.new(self, body, trailer)
	
	@output.start
end</code></pre>
					</details></section><section id="Async::HTTP::Protocol::HTTP2::Stream#finish_output"><h3><code class="language-ruby">def finish_output(error = nil)</code></h3><p>Called when the output terminates normally.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def finish_output(error = nil)
	trailer = @output&amp;.trailer
	
	@output = nil
	
	if error
		send_reset_stream(::Protocol::HTTP2::Error::INTERNAL_ERROR)
	else
		# Write trailer?
		if trailer&amp;.any?
			send_headers(nil, trailer, ::Protocol::HTTP2::END_STREAM)
		else
			send_data(nil, ::Protocol::HTTP2::END_STREAM)
		end
	end
end</code></pre>
					</details></section><section id="Async::HTTP::Protocol::HTTP2::Stream#closed"><h3><code class="language-ruby">def closed(error)</code></h3><p>When the stream transitions to the closed state, this method is called. There are roughly two ways this can happen:</p>
<ul>
<li>A frame is received which causes this stream to enter the closed state. This method will be invoked from the background reader task.</li>
<li>A frame is sent which causes this stream to enter the closed state. This method will be invoked from that task.
While the input stream is relatively straight forward, the output stream can trigger the second case above</li>
</ul>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def closed(error)
	super
	
	if @input
		@input.close(error)
		@input = nil
	end
	
	if @output
		@output.stop(error)
		@output = nil
	end
	
	return self
end</code></pre>
					</details></section>	</section>
	
	

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>

