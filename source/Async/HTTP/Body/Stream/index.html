<!DOCTYPE html>
<html>
	<head>
		
			<title>Async::HTTP::Body::Stream</title>
		
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		
		<link rel="icon" type="image/png" href="../../../../../_static/icon.png"/>
		<link rel="stylesheet" href="../../../../../_static/site.css" type="text/css" media="screen"/>
		
		<script src="../../../../../_components/jquery/jquery.min.js"></script>
		<script src="../../../../../_components/jquery-syntax/jquery.syntax.min.js"></script>
		<script src="../../../../../_components/mermaid/mermaid.min.js"></script>
		
		<script src="../../../../../_static/links.js"></script>
		
		<script type="text/javascript">
		//<![CDATA[
			jQuery(function($) {
				$.syntax();
			});
			
			let isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
			let config = {theme: 'light'};
			if (isDarkMode) config.theme = 'dark';
			else config.theme = 'forest';
			mermaid.initialize(config);
		//]]>
		</script>
	</head>

	<body>
		<header> › <a class="link" href="../../../../../index.html">Project</a> › <a class="link" href="../../../../index.html">Source</a></header>
		
		<main>
			
	<h1>Async::HTTP::Body::Stream</h1>
	
	<p>
		<code class="language-ruby">class Async::HTTP::Body::Stream</code>
	</p>
	
	<p>The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.</p>
	
	
	
	
	<section>
	<h2>Definitions</h2>
	
	<section id="Async::HTTP::Body::Stream#read"><h3><code class="language-ruby">def read(size = nil, buffer = nil)</code></h3><p>read behaves like IO#read. Its signature is read([length, [buffer]]). If given, length must be a non-negative Integer (&gt;= 0) or nil, and buffer must be a String and may not be nil. If length is given and not nil, then this method reads at most length bytes from the input stream. If length is not given or nil, then this method reads all data until EOF. When EOF is reached, this method returns nil if length is given and not nil, or “” if length is not given or is nil. If buffer is given, then the read data will be placed into buffer instead of a newly created String object.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def read(size = nil, buffer = nil)
	return '' if size == 0
	
	buffer ||= Async::IO::Buffer.new
	if @buffer
		buffer.replace(@buffer)
		@buffer = nil
	end
	
	if size
		while buffer.bytesize &lt; size and chunk = read_next
			buffer &lt;&lt; chunk
		end
		
		@buffer = buffer.byteslice(size, buffer.bytesize)
		buffer = buffer.byteslice(0, size)
		
		if buffer.empty?
			return nil
		else
			return buffer
		end
	else
		while chunk = read_next
			buffer &lt;&lt; chunk
		end
		
		return buffer
	end
end</code></pre>
					</details></section><section id="Async::HTTP::Body::Stream#read_partial"><h3><code class="language-ruby">def read_partial(size = nil)</code></h3><p>Read at most <code>size</code> bytes from the stream. Will avoid reading from the underlying stream if possible.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def read_partial(size = nil)
	if @buffer
		buffer = @buffer
		@buffer = nil
	else
		buffer = read_next
	end
	
	if buffer and size
		if buffer.bytesize &gt; size
			@buffer = buffer.byteslice(size, buffer.bytesize)
			buffer = buffer.byteslice(0, size)
		end
	end
	
	return buffer
end</code></pre>
					</details></section><section id="Async::HTTP::Body::Stream#close"><h3><code class="language-ruby">def close(error = nil)</code></h3><p>Close the input and output bodies.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def close(error = nil)
	self.close_read
	self.close_write
ensure
	@closed = true
end</code></pre>
					</details></section><section id="Async::HTTP::Body::Stream#closed?"><h3><code class="language-ruby">def closed?</code></h3><p>Whether the stream has been closed.</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def closed?
	@closed
end</code></pre>
					</details></section><section id="Async::HTTP::Body::Stream#empty?"><h3><code class="language-ruby">def empty?</code></h3><p>Whether there are any output chunks remaining?</p>
<details>
						<summary><h4>Implementation</h4></summary>
						<pre><code class="language-ruby">def empty?
	@output.empty?
end</code></pre>
					</details></section>	</section>
	
	

				
			<footer>Documentation generated by <a href="https://github.com/socketry/utopia-project">Utopia::Project</a>.</footer>
		</main>
	</body>
</html>

